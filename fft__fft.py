"""
# coef1 = (аргументы[0] + аргументы[2]) % 17: Добавляет первый и третий элементы входного списка args,
# принимает результат по модулю 17 и присваивает его переменной coef1.

# коэффициент 2 = ((аргументы[0] - аргументы[2]) + 17) % 17:
# Вычитает третий элемент из первого элемента аргументов, добавляет 17 к результату,
# принимает результат по модулю 17 и присваивает его переменной coef2.

# coef3 = (аргументы[1] + аргументы[3]) % 17: Добавляет второй и четвертый элементы аргументов,
# принимает результат по модулю 17 и присваивает его переменной coef3.

# коэффициент 4 = ((аргументы[1] - аргументы[3]) + 17) % 17:
# Вычитает четвертый элемент из второго элемента аргументов, добавляет 17 к результату,
# принимает результат по модулю 17 и присваивает его переменной coef4.

# массив = [(coef1 + coef3) % 17, (coef2 + 4 * coef4) % 17, (coef1 - coef3 + 17 * 100) % 17,
# (( коэффициент полезного действия 2 - 4 * коэффициент полезного действия 4) + 17 * 100) % 17]:
# Создает новый список, содержащий четыре элемента,
# каждый из который представляет собой полиномиальный коэффициент, вычисленный с использованием предыдущих строк.

# возвращаемый массив: Возвращает список полиномиальных коэффициентов.
"""


def FFT(args):
    coef1 = (args[0] + args[2]) % 17
    coef2 = ((args[0] - args[2]) + 17) % 17
    coef3 = (args[1] + args[3]) % 17
    coef4 = ((args[1] - args[3]) + 17) % 17

    array = [
        (coef1 + coef3) % 17,
        (coef2 + 4 * coef4) % 17,
        (coef1 - coef3 + 17 * 100) % 17,
        ((coef2 - 4 * coef4) + 17 * 100) % 17
    ]

    return array


"""
# Модифицированная функция __FFT(args) по существу такая же, как исходная функция FFT(args),
# но с добавленным шагом в конце, который умножает каждый элемент в результирующем массиве на 13 по модулю 17.

# i = 0: Инициализируйте переменную счетчика, чтобы отслеживать текущий индекс в массиве.
# в то время как i < len(array):: Перебирает каждый элемент в массиве.
# array[i] = array[i] * 13 % 17: Умножьте текущий элемент на 13,
# затем умножьте результат по модулю 17, чтобы получить конечное значение.
# Это делается на месте путем перезаписи текущего элемента новым значением.
# i += 1: Увеличьте переменную счетчика, чтобы перейти к следующему элементу.
# Цель этой модификации не сразу понятна без дополнительного контекста,
# поскольку она зависит от конкретного варианта использования функции FFT().
# Однако, по-видимому, предполагается, что конечный результат алгоритма БПФ каким-то образом масштабируется
# или нормализуется с использованием умножения на 13 по модулю 17.
"""


def __FFT(args):
    coef1 = (args[0] + args[2]) % 17
    coef2 = ((args[0] - args[2]) + 17) % 17
    coef3 = (args[1] + args[3]) % 17
    coef4 = ((args[1] - args[3]) + 17) % 17

    array = [
        (coef1 + coef3) % 17,
        (coef2 + 4 * coef4) % 17,
        (coef1 - coef3 + 17 * 100) % 17,
        ((coef2 - 4 * coef4) + 17 * 100) % 17
    ]

    i = 0
    while i < len(array):
        array[i] = array[i] * 13 % 17
        i += 1
    return array


print(FFT([3, 1, 2, 4]))
print(__FFT([10, 6, 0, 13]))
