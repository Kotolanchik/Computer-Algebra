from math import isqrt, sqrt, gcd

"""
Функция sherman_leman принимает целое число n и пытается найти его нетривиальные множители, используя алгоритм Шермана-Лемана.

Функция сначала проверяет, меньше ли n 9, и если это так, выдает ошибку ValueError, поскольку алгоритм работает только для n, большего 8.

Затем функция выполняет итерацию по всем целым числам a от 2 до кубического корня из n (включительно). Если n делится на a, то a является нетривиальным множителем n, и функция возвращает [a, n//a].

Если на предыдущем шаге не найдено никаких факторов, функция переходит во вложенный цикл. Внешний цикл выполняет итерацию по всем целым числам k от 1 до кубического корня из n. Внутренний цикл выполняет итерацию по всем целым числам d от 0 до значения, вычисляемого как int(pow(n, 1/6) / (4 * sqrt(k))) + 2. Для каждой пары k и d функция вычисляет sqr как pow(int(sqrt(4 * k * n)) + d, 2) - 4 * k * n. Если sqr является идеальным квадратом и больше или равен 1, то функция выполняет следующие шаги:

Вычислите A как int(sqrt(4 * k * n)) + d
Вычислите B как isqrt(A * A - 4 * k * n), где isqrt - это функция, которая вычисляет целый квадратный корень из числа.
Вычислите A_plus_B_GCD как наибольший общий делитель A + B и n.
Вычислите A_minus_B_GCD как наибольший общий делитель A - B и n.
Если и A_plus_B_GCD, и A_minus_B_GCD больше 1 и меньше n, то функция возвращает [A_minus_B_GCD, n // A_minus_B_GCD].
Если функция еще не нашла никаких факторов, она возвращает [1, n] в качестве последнего средства.
"""
def sherman_leman(n: int) -> list:
    if n < 9:
        raise ValueError('n must be greater then 8')

    for a in range(2, int(pow(n, 1 / 3))):
        if n % a == 0:
            return [a, n // a]

    for k in range(1, int(pow(n, 1 / 3))):
        for d in range(int(pow(n, 1 / 6) / (4 * sqrt(k))) + 2):
            sqr = pow(int(sqrt(4 * k * n)) + d, 2) - 4 * k * n
            if sqr >= 1 and sqr == isqrt(sqr) ** 2:
                A = int(sqrt(4 * k * n)) + d
                B = isqrt(A * A - 4 * k * n)
                A_plus_B_GCD = gcd(A + B, n)
                A_minus_B_GCD = gcd(A - B, n)
                if 1 < A_plus_B_GCD < n and 1 < A_minus_B_GCD < n:
                    return [A_minus_B_GCD, n // A_minus_B_GCD]

    return [1, n]
